<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª ×©×œ ×¡×•×’×™ ×œ××™×“×” ××›×•× ×”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            direction: rtl;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        header h1 {
            color: #333;
            font-size: 32px;
            margin-bottom: 10px;
        }

        header p {
            color: #666;
            font-size: 16px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 15px 30px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #555;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .content-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        .panel-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .panel-header h2 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
        }

        .panel-header p {
            color: #666;
            font-size: 16px;
            line-height: 1.6;
        }

        .visualization-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }

        .control-group label {
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .info-box {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            border-right: 4px solid #667eea;
        }

        .info-box h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .info-box ul {
            color: #555;
            line-height: 1.8;
            padding-right: 20px;
        }

        .hidden {
            display: none;
        }

        .status {
            text-align: center;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 8px;
            color: #2e7d32;
            font-weight: 600;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ¤– ×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª ×©×œ ×œ××™×“×” ××›×•× ×”</h1>
            <p>×’×œ×” ××ª ×”×¡×•×’×™× ×”×©×•× ×™× ×©×œ ××œ×’×•×¨×™×ª××™ ×œ××™×“×” ××›×•× ×” ×“×¨×š ×•×™×–×•××œ×™×–×¦×™×•×ª ××™× ×˜×¨××§×˜×™×‘×™×•×ª</p>
        </header>

        <div class="tabs">
            <button class="tab active" data-tab="supervised">×œ××™×“×” ××•× ×—×™×ª</button>
            <button class="tab" data-tab="unsupervised">×œ××™×“×” ×œ× ××•× ×—×™×ª</button>
            <button class="tab" data-tab="reinforcement">×œ××™×“×” ×‘×—×™×–×•×§</button>
            <button class="tab" data-tab="neural">×¨×©×ª×•×ª × ×•×™×¨×•× ×™×</button>
        </div>

        <!-- ×œ××™×“×” ××•× ×—×™×ª -->
        <div id="supervised" class="content-panel">
            <div class="panel-header">
                <h2>ğŸ“š ×œ××™×“×” ××•× ×—×™×ª (Supervised Learning)</h2>
                <p>×”××•×“×œ ×œ×•××“ ××ª×•×š ×“×•×’×××•×ª ××¡×•×× ×•×ª. ×›×•×œ×œ ×¡×™×•×•×’ (Classification) ×•×¨×’×¨×¡×™×” (Regression)</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>×¡×•×’ ××©×™××”:</label>
                    <select id="supervisedType" style="padding: 10px; border-radius: 8px; border: 2px solid #ddd;">
                        <option value="classification">×¡×™×•×•×’ (Classification)</option>
                        <option value="regression">×¨×’×¨×¡×™×” (Regression)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>××¡×¤×¨ × ×§×•×“×•×ª × ×ª×•× ×™×: <span id="dataPointsValue">50</span></label>
                    <input type="range" id="dataPoints" min="20" max="200" step="10" value="50">
                </div>
                <button id="trainSupervised">ğŸ“ ××™××•×Ÿ ×”××•×“×œ</button>
                <button id="resetSupervised">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="supervisedCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ××•× ×—×™×ª?</h3>
                <ul>
                    <li><strong>×¡×™×•×•×’:</strong> ×—×™×–×•×™ ×§×˜×’×•×¨×™×” (×œ××©×œ: ×—×ª×•×œ/×›×œ×‘, ×¡×¤××/×œ× ×¡×¤××)</li>
                    <li><strong>×¨×’×¨×¡×™×”:</strong> ×—×™×–×•×™ ×¢×¨×š ××¡×¤×¨×™ ×¨×¦×™×£ (×œ××©×œ: ××—×™×¨, ×˜××¤×¨×˜×•×¨×”)</li>
                    <li>×”××•×“×œ ×œ×•××“ ××ª×•×š ×“×•×’×××•×ª ×¢× ×ª×©×•×‘×•×ª × ×›×•× ×•×ª</li>
                    <li>×“×•×’×××•×ª: ×–×™×”×•×™ ×ª××•× ×•×ª, × ×™×ª×•×— ×¡× ×˜×™×× ×˜, ×—×™×–×•×™ ××—×™×¨×™×</li>
                </ul>
            </div>
            <div class="status" id="supervisedStatus">××•×›×Ÿ ×œ××™××•×Ÿ</div>
        </div>

        <!-- ×œ××™×“×” ×œ× ××•× ×—×™×ª -->
        <div id="unsupervised" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ” ×œ××™×“×” ×œ× ××•× ×—×™×ª (Unsupervised Learning)</h2>
                <p>×”××•×“×œ ××•×¦× ×“×¤×•×¡×™× ×‘× ×ª×•× ×™× ×œ×œ× ×ª×™×•×’×™×. ×›×•×œ×œ ×§×™×‘×•×¥ (Clustering) ×•×¦××¦×•× ×××“×™×</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>×¡×•×’ ××œ×’×•×¨×™×ª×:</label>
                    <select id="unsupervisedType" style="padding: 10px; border-radius: 8px; border: 2px solid #ddd;">
                        <option value="kmeans">K-Means Clustering</option>
                        <option value="dbscan">DBSCAN</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>××¡×¤×¨ ××©×›×•×œ×•×ª: <span id="clustersValue">3</span></label>
                    <input type="range" id="clusters" min="2" max="8" step="1" value="3">
                </div>
                <button id="trainUnsupervised">ğŸ“ ××¦× ××©×›×•×œ×•×ª</button>
                <button id="resetUnsupervised">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="unsupervisedCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ×œ× ××•× ×—×™×ª?</h3>
                <ul>
                    <li><strong>×§×™×‘×•×¥:</strong> ××¦×™××ª ×§×‘×•×¦×•×ª ×“×•××•×ª ×‘× ×ª×•× ×™×</li>
                    <li><strong>×¦××¦×•× ×××“×™×:</strong> ×”×¤×—×ª×ª ××¡×¤×¨ ×”×ª×›×•× ×•×ª ×ª×•×š ×©××™×¨×” ×¢×œ ××™×“×¢</li>
                    <li>×”××•×“×œ ××•×¦× ×“×¤×•×¡×™× ×œ×œ× ×“×•×’×××•×ª ××¡×•×× ×•×ª</li>
                    <li>×“×•×’×××•×ª: ×”××œ×¦×•×ª, ×–×™×”×•×™ ×× ×•××œ×™×•×ª, × ×™×ª×•×— ×©×•×§</li>
                </ul>
            </div>
            <div class="status" id="unsupervisedStatus">××•×›×Ÿ ×œ× ×™×ª×•×—</div>
        </div>

        <!-- ×œ××™×“×” ×‘×—×™×–×•×§ -->
        <div id="reinforcement" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ® ×œ××™×“×” ×‘×—×™×–×•×§ (Reinforcement Learning)</h2>
                <p>×¡×•×›×Ÿ ×œ×•××“ ×“×¨×š × ×™×¡×•×™ ×•×˜×¢×™×™×”, ××§×‘×œ ×ª×’××•×œ×™× ×¢×œ ×¤×¢×•×œ×•×ª × ×›×•× ×•×ª</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>××”×™×¨×•×ª ×œ××™×“×”: <span id="learningRateValue">0.1</span></label>
                    <input type="range" id="learningRate" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <label>×’×•×¨× ×”× ×—×”: <span id="discountValue">0.9</span></label>
                    <input type="range" id="discount" min="0.5" max="0.99" step="0.01" value="0.9">
                </div>
                <button id="startRL">â–¶ ×”×ª×—×œ ××™××•×Ÿ</button>
                <button id="resetRL">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="reinforcementCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ×‘×—×™×–×•×§?</h3>
                <ul>
                    <li>×¡×•×›×Ÿ ×œ×•××“ ×“×¨×š ××™× ×˜×¨××§×¦×™×” ×¢× ×¡×‘×™×‘×”</li>
                    <li>××§×‘×œ ×ª×’××•×œ×™× ×—×™×•×‘×™×™× ××• ×©×œ×™×œ×™×™× ×¢×œ ×¤×¢×•×œ×•×ª</li>
                    <li>××˜×¨×ª×• ×œ××§×¡× ××ª ×¡×›×•× ×”×ª×’××•×œ×™× ×”×¢×ª×™×“×™×™×</li>
                    <li>×“×•×’×××•×ª: ××©×—×§×™×, ×¨×•×‘×•×˜×™×§×”, × ×™×”×•×œ ××œ××™, × ×”×™×’×” ××•×˜×•× ×•××™×ª</li>
                </ul>
            </div>
            <div class="status" id="reinforcementStatus">××•×›×Ÿ ×œ×”×ª×—×œ×”</div>
        </div>

        <!-- ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× -->
        <div id="neural" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ§  ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× (Neural Networks)</h2>
                <p>××•×“×œ×™× ×”××‘×•×¡×¡×™× ×¢×œ ××‘× ×” ×”××•×—, ××•×¨×›×‘×™× ×× ×•×™×¨×•× ×™× ×”××—×•×‘×¨×™× ×‘×©×›×‘×•×ª</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>××¡×¤×¨ ×©×›×‘×•×ª × ×¡×ª×¨×•×ª: <span id="layersValue">2</span></label>
                    <input type="range" id="layers" min="1" max="5" step="1" value="2">
                </div>
                <div class="control-group">
                    <label>× ×•×™×¨×•× ×™× ×‘×©×›×‘×”: <span id="neuronsValue">4</span></label>
                    <input type="range" id="neurons" min="2" max="10" step="1" value="4">
                </div>
                <button id="trainNeural">ğŸ“ ××™××•×Ÿ ×”×¨×©×ª</button>
                <button id="resetNeural">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×¨×©×ª×•×ª × ×•×™×¨×•× ×™×?</h3>
                <ul>
                    <li>××•×“×œ×™× ×”××—×§×™× ××ª ×¤×¢×•×œ×ª ×”××•×— ×”×× ×•×©×™</li>
                    <li>××•×¨×›×‘×™× ×× ×•×™×¨×•× ×™× ×”××—×•×‘×¨×™× ×‘×©×›×‘×•×ª</li>
                    <li>×œ×•××“×™× ×“×¤×•×¡×™× ××•×¨×›×‘×™× ×“×¨×š ××™××•×Ÿ</li>
                    <li>×“×•×’×××•×ª: ×–×™×”×•×™ ×ª××•× ×•×ª, ×¢×™×‘×•×“ ×©×¤×” ×˜×‘×¢×™×ª, ×ª×¨×’×•× ××•×˜×•××˜×™</li>
                </ul>
            </div>
            <div class="status" id="neuralStatus">××•×›×Ÿ ×œ××™××•×Ÿ</div>
        </div>
    </div>

    <script>
        // × ×™×”×•×œ ×˜××‘×™×
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                
                // ×¢×“×›×•×Ÿ ×˜××‘×™×
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // ×¢×“×›×•×Ÿ ×¤×× ×œ×™×
                document.querySelectorAll('.content-panel').forEach(p => p.classList.add('hidden'));
                document.getElementById(targetTab).classList.remove('hidden');
            });
        });

        // ========== ×œ××™×“×” ××•× ×—×™×ª ==========
        const supervisedCanvas = document.getElementById('supervisedCanvas');
        const supervisedCtx = supervisedCanvas.getContext('2d');
        let supervisedData = [];
        let supervisedModel = null;
        let isTrainingSupervised = false;

        function resizeCanvas(canvas) {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        resizeCanvas(supervisedCanvas);
        window.addEventListener('resize', () => resizeCanvas(supervisedCanvas));

        function generateSupervisedData(type, count) {
            const data = [];
            const width = supervisedCanvas.width;
            const height = supervisedCanvas.height;
            
            for (let i = 0; i < count; i++) {
                const x = Math.random() * width;
                let y;
                
                if (type === 'classification') {
                    // ×™×¦×™×¨×ª ×©× ×™ ××©×›×•×œ×•×ª
                    const cluster = Math.random() < 0.5 ? 0 : 1;
                    const centerX = cluster === 0 ? width * 0.3 : width * 0.7;
                    const centerY = height * 0.5;
                    const offsetX = (Math.random() - 0.5) * width * 0.2;
                    const offsetY = (Math.random() - 0.5) * height * 0.3;
                    y = centerY + offsetY + Math.sin(x / width * Math.PI * 2) * height * 0.1;
                    data.push({ x, y, label: cluster });
                } else {
                    // ×¨×’×¨×¡×™×” - ×§×• ×¢× ×¨×¢×©
                    y = height * 0.3 + (x / width) * height * 0.4 + (Math.random() - 0.5) * height * 0.2;
                    data.push({ x, y });
                }
            }
            
            return data;
        }

        function drawSupervised(type) {
            supervisedCtx.clearRect(0, 0, supervisedCanvas.width, supervisedCanvas.height);
            
            if (type === 'classification') {
                supervisedData.forEach(point => {
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    supervisedCtx.fillStyle = point.label === 0 ? '#e74c3c' : '#3498db';
                    supervisedCtx.fill();
                });
                
                // ×¦×™×•×¨ ×§×• ×”×”×¤×¨×“×” ×× ×”××•×“×œ ×××•××Ÿ
                if (supervisedModel) {
                    supervisedCtx.strokeStyle = '#2ecc71';
                    supervisedCtx.lineWidth = 3;
                    supervisedCtx.beginPath();
                    const midX = supervisedCanvas.width / 2;
                    supervisedCtx.moveTo(midX, 0);
                    supervisedCtx.lineTo(midX, supervisedCanvas.height);
                    supervisedCtx.stroke();
                }
            } else {
                supervisedData.forEach(point => {
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                    supervisedCtx.fillStyle = '#9b59b6';
                    supervisedCtx.fill();
                });
                
                // ×¦×™×•×¨ ×§×• ×”×¨×’×¨×¡×™×” ×× ×”××•×“×œ ×××•××Ÿ
                if (supervisedModel) {
                    supervisedCtx.strokeStyle = '#e67e22';
                    supervisedCtx.lineWidth = 3;
                    supervisedCtx.beginPath();
                    for (let x = 0; x < supervisedCanvas.width; x += 5) {
                        const y = supervisedModel.slope * x + supervisedModel.intercept;
                        if (x === 0) supervisedCtx.moveTo(x, y);
                        else supervisedCtx.lineTo(x, y);
                    }
                    supervisedCtx.stroke();
                }
            }
        }

        document.getElementById('supervisedType').addEventListener('change', (e) => {
            const count = parseInt(document.getElementById('dataPoints').value);
            supervisedData = generateSupervisedData(e.target.value, count);
            supervisedModel = null;
            drawSupervised(e.target.value);
        });

        document.getElementById('dataPoints').addEventListener('input', (e) => {
            document.getElementById('dataPointsValue').textContent = e.target.value;
            const type = document.getElementById('supervisedType').value;
            supervisedData = generateSupervisedData(type, parseInt(e.target.value));
            supervisedModel = null;
            drawSupervised(type);
        });

        document.getElementById('trainSupervised').addEventListener('click', () => {
            if (isTrainingSupervised) return;
            isTrainingSupervised = true;
            const type = document.getElementById('supervisedType').value;
            document.getElementById('supervisedStatus').textContent = '××××Ÿ...';
            
            setTimeout(() => {
                if (type === 'classification') {
                    supervisedModel = { trained: true };
                } else {
                    // ×¨×’×¨×¡×™×” ×œ×™× ×™××¨×™×ª ×¤×©×•×˜×”
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    supervisedData.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        sumXY += p.x * p.y;
                        sumX2 += p.x * p.x;
                    });
                    const n = supervisedData.length;
                    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    supervisedModel = { slope, intercept };
                }
                drawSupervised(type);
                document.getElementById('supervisedStatus').textContent = '××™××•×Ÿ ×”×•×©×œ×!';
                isTrainingSupervised = false;
            }, 1000);
        });

        document.getElementById('resetSupervised').addEventListener('click', () => {
            const type = document.getElementById('supervisedType').value;
            const count = parseInt(document.getElementById('dataPoints').value);
            supervisedData = generateSupervisedData(type, count);
            supervisedModel = null;
            drawSupervised(type);
            document.getElementById('supervisedStatus').textContent = '××•×›×Ÿ ×œ××™××•×Ÿ';
        });

        // ××ª×—×•×œ
        const supervisedType = document.getElementById('supervisedType').value;
        supervisedData = generateSupervisedData(supervisedType, 50);
        drawSupervised(supervisedType);

        // ========== ×œ××™×“×” ×œ× ××•× ×—×™×ª ==========
        const unsupervisedCanvas = document.getElementById('unsupervisedCanvas');
        const unsupervisedCtx = unsupervisedCanvas.getContext('2d');
        let unsupervisedData = [];
        let clusters = [];
        let isTrainingUnsupervised = false;

        resizeCanvas(unsupervisedCanvas);
        window.addEventListener('resize', () => resizeCanvas(unsupervisedCanvas));

        function generateUnsupervisedData(count) {
            const data = [];
            const width = unsupervisedCanvas.width;
            const height = unsupervisedCanvas.height;
            
            // ×™×¦×™×¨×ª 3 ××©×›×•×œ×•×ª ×˜×‘×¢×™×™×
            const centers = [
                { x: width * 0.3, y: height * 0.3 },
                { x: width * 0.7, y: height * 0.3 },
                { x: width * 0.5, y: height * 0.7 }
            ];
            
            for (let i = 0; i < count; i++) {
                const center = centers[Math.floor(Math.random() * centers.length)];
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * Math.min(width, height) * 0.15;
                data.push({
                    x: center.x + Math.cos(angle) * radius,
                    y: center.y + Math.sin(angle) * radius
                });
            }
            
            return data;
        }

        function kMeans(data, k) {
            const width = unsupervisedCanvas.width;
            const height = unsupervisedCanvas.height;
            
            // ××ª×—×•×œ ××¨×›×–×™ ××©×›×•×œ×•×ª ××§×¨××™×™×
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * width,
                    y: Math.random() * height
                });
            }
            
            // ××™×˜×¨×¦×™×•×ª
            for (let iter = 0; iter < 10; iter++) {
                const assignments = data.map(point => {
                    let minDist = Infinity;
                    let cluster = 0;
                    centroids.forEach((centroid, idx) => {
                        const dist = Math.sqrt(
                            Math.pow(point.x - centroid.x, 2) + 
                            Math.pow(point.y - centroid.y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            cluster = idx;
                        }
                    });
                    return cluster;
                });
                
                // ×¢×“×›×•×Ÿ ××¨×›×–×™ ××©×›×•×œ×•×ª
                centroids = centroids.map((_, idx) => {
                    const clusterPoints = data.filter((_, i) => assignments[i] === idx);
                    if (clusterPoints.length === 0) return centroids[idx];
                    const sumX = clusterPoints.reduce((s, p) => s + p.x, 0);
                    const sumY = clusterPoints.reduce((s, p) => s + p.y, 0);
                    return {
                        x: sumX / clusterPoints.length,
                        y: sumY / clusterPoints.length
                    };
                });
            }
            
            return { centroids, assignments };
        }

        function drawUnsupervised() {
            unsupervisedCtx.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
            
            if (clusters.length > 0) {
                unsupervisedData.forEach((point, idx) => {
                    const cluster = clusters.assignments[idx];
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = colors[cluster % colors.length];
                    unsupervisedCtx.fill();
                });
                
                // ×¦×™×•×¨ ××¨×›×–×™ ××©×›×•×œ×•×ª
                clusters.centroids.forEach((centroid, idx) => {
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(centroid.x, centroid.y, 12, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = colors[idx % colors.length];
                    unsupervisedCtx.fill();
                    unsupervisedCtx.strokeStyle = '#fff';
                    unsupervisedCtx.lineWidth = 3;
                    unsupervisedCtx.stroke();
                });
            } else {
                unsupervisedData.forEach(point => {
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = '#95a5a6';
                    unsupervisedCtx.fill();
                });
            }
        }

        document.getElementById('clusters').addEventListener('input', (e) => {
            document.getElementById('clustersValue').textContent = e.target.value;
        });

        document.getElementById('trainUnsupervised').addEventListener('click', () => {
            if (isTrainingUnsupervised) return;
            isTrainingUnsupervised = true;
            const k = parseInt(document.getElementById('clusters').value);
            document.getElementById('unsupervisedStatus').textContent = '××—×©×‘ ××©×›×•×œ×•×ª...';
            
            setTimeout(() => {
                clusters = kMeans(unsupervisedData, k);
                drawUnsupervised();
                document.getElementById('unsupervisedStatus').textContent = `× ××¦××• ${k} ××©×›×•×œ×•×ª!`;
                isTrainingUnsupervised = false;
            }, 800);
        });

        document.getElementById('resetUnsupervised').addEventListener('click', () => {
            unsupervisedData = generateUnsupervisedData(100);
            clusters = [];
            drawUnsupervised();
            document.getElementById('unsupervisedStatus').textContent = '××•×›×Ÿ ×œ× ×™×ª×•×—';
        });

        // ××ª×—×•×œ
        unsupervisedData = generateUnsupervisedData(100);
        drawUnsupervised();

        // ========== ×œ××™×“×” ×‘×—×™×–×•×§ ==========
        const reinforcementCanvas = document.getElementById('reinforcementCanvas');
        const reinforcementCtx = reinforcementCanvas.getContext('2d');
        let agent = { x: 0, y: 0 };
        let target = { x: 0, y: 0 };
        let rlAnimation = null;
        let episode = 0;
        let score = 0;

        resizeCanvas(reinforcementCanvas);
        window.addEventListener('resize', () => resizeCanvas(reinforcementCanvas));

        function initRL() {
            agent.x = reinforcementCanvas.width * 0.1;
            agent.y = reinforcementCanvas.height * 0.5;
            target.x = reinforcementCanvas.width * 0.9;
            target.y = reinforcementCanvas.height * 0.5;
        }

        function drawRL() {
            reinforcementCtx.clearRect(0, 0, reinforcementCanvas.width, reinforcementCanvas.height);
            
            // ×¨×§×¢
            reinforcementCtx.fillStyle = '#ecf0f1';
            reinforcementCtx.fillRect(0, 0, reinforcementCanvas.width, reinforcementCanvas.height);
            
            // ××˜×¨×”
            reinforcementCtx.beginPath();
            reinforcementCtx.arc(target.x, target.y, 20, 0, Math.PI * 2);
            reinforcementCtx.fillStyle = '#2ecc71';
            reinforcementCtx.fill();
            reinforcementCtx.strokeStyle = '#27ae60';
            reinforcementCtx.lineWidth = 3;
            reinforcementCtx.stroke();
            
            // ×¡×•×›×Ÿ
            reinforcementCtx.beginPath();
            reinforcementCtx.arc(agent.x, agent.y, 15, 0, Math.PI * 2);
            reinforcementCtx.fillStyle = '#e74c3c';
            reinforcementCtx.fill();
            reinforcementCtx.strokeStyle = '#c0392b';
            reinforcementCtx.lineWidth = 2;
            reinforcementCtx.stroke();
            
            // ××™×“×¢
            reinforcementCtx.fillStyle = '#333';
            reinforcementCtx.font = '16px Arial';
            reinforcementCtx.fillText(`××¤×™×–×•×“×”: ${episode}`, 20, 30);
            reinforcementCtx.fillText(`× ×™×§×•×“: ${score}`, 20, 55);
        }

        document.getElementById('learningRate').addEventListener('input', (e) => {
            document.getElementById('learningRateValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('discount').addEventListener('input', (e) => {
            document.getElementById('discountValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('startRL').addEventListener('click', () => {
            if (rlAnimation) return;
            
            initRL();
            episode = 0;
            score = 0;
            
            rlAnimation = setInterval(() => {
                // ×ª× ×•×¢×” ××§×¨××™×ª ×œ×›×™×•×•×Ÿ ×”××˜×¨×” (×¡×™××•×œ×¦×™×” ×¤×©×•×˜×”)
                const dx = target.x - agent.x;
                const dy = target.y - agent.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    agent.x += (dx / dist) * 3 + (Math.random() - 0.5) * 10;
                    agent.y += (dy / dist) * 3 + (Math.random() - 0.5) * 10;
                    
                    // ×”×’×‘×œ×•×ª
                    agent.x = Math.max(15, Math.min(reinforcementCanvas.width - 15, agent.x));
                    agent.y = Math.max(15, Math.min(reinforcementCanvas.height - 15, agent.y));
                } else {
                    // ×”×’×¢×” ×œ××˜×¨×”
                    score += 10;
                    episode++;
                    initRL();
                }
                
                drawRL();
            }, 50);
            
            document.getElementById('reinforcementStatus').textContent = '××ª×××Ÿ...';
        });

        document.getElementById('resetRL').addEventListener('click', () => {
            if (rlAnimation) {
                clearInterval(rlAnimation);
                rlAnimation = null;
            }
            initRL();
            episode = 0;
            score = 0;
            drawRL();
            document.getElementById('reinforcementStatus').textContent = '××•×›×Ÿ ×œ×”×ª×—×œ×”';
        });

        // ××ª×—×•×œ
        initRL();
        drawRL();

        // ========== ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× ==========
        const neuralCanvas = document.getElementById('neuralCanvas');
        const neuralCtx = neuralCanvas.getContext('2d');
        let neuralNetwork = null;
        let isTrainingNeural = false;

        resizeCanvas(neuralCanvas);
        window.addEventListener('resize', () => resizeCanvas(neuralCanvas));

        function createNeuralNetwork(inputSize, hiddenLayers, hiddenSize, outputSize) {
            const network = {
                layers: []
            };
            
            // ×©×›×‘×ª ×§×œ×˜
            network.layers.push({
                neurons: Array(inputSize).fill(0).map(() => ({ value: Math.random() }))
            });
            
            // ×©×›×‘×•×ª × ×¡×ª×¨×•×ª
            for (let i = 0; i < hiddenLayers; i++) {
                network.layers.push({
                    neurons: Array(hiddenSize).fill(0).map(() => ({ value: Math.random() }))
                });
            }
            
            // ×©×›×‘×ª ×¤×œ×˜
            network.layers.push({
                neurons: Array(outputSize).fill(0).map(() => ({ value: Math.random() }))
            });
            
            return network;
        }

        function drawNeuralNetwork() {
            neuralCtx.clearRect(0, 0, neuralCanvas.width, neuralCanvas.height);
            
            if (!neuralNetwork) return;
            
            const layers = neuralNetwork.layers;
            const layerWidth = neuralCanvas.width / (layers.length + 1);
            const neuronRadius = 20;
            
            // ×¦×™×•×¨ × ×•×™×¨×•× ×™×
            layers.forEach((layer, layerIdx) => {
                const x = layerWidth * (layerIdx + 1);
                const neuronSpacing = neuralCanvas.height / (layer.neurons.length + 1);
                
                layer.neurons.forEach((neuron, neuronIdx) => {
                    const y = neuronSpacing * (neuronIdx + 1);
                    
                    // ×§×™×©×•×¨×™× ×œ×©×›×‘×” ×”×‘××”
                    if (layerIdx < layers.length - 1) {
                        const nextLayer = layers[layerIdx + 1];
                        const nextNeuronSpacing = neuralCanvas.height / (nextLayer.neurons.length + 1);
                        const nextX = layerWidth * (layerIdx + 2);
                        
                        nextLayer.neurons.forEach((_, nextNeuronIdx) => {
                            const nextY = nextNeuronSpacing * (nextNeuronIdx + 1);
                            
                            neuralCtx.beginPath();
                            neuralCtx.moveTo(x, y);
                            neuralCtx.lineTo(nextX, nextY);
                            neuralCtx.strokeStyle = `rgba(102, 126, 234, ${Math.abs(neuron.value) * 0.3})`;
                            neuralCtx.lineWidth = 1;
                            neuralCtx.stroke();
                        });
                    }
                    
                    // × ×•×™×¨×•×Ÿ
                    neuralCtx.beginPath();
                    neuralCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    const intensity = Math.min(1, Math.abs(neuron.value));
                    neuralCtx.fillStyle = `rgba(102, 126, 234, ${intensity})`;
                    neuralCtx.fill();
                    neuralCtx.strokeStyle = '#667eea';
                    neuralCtx.lineWidth = 2;
                    neuralCtx.stroke();
                });
            });
            
            // ×ª×•×•×™×•×ª
            neuralCtx.fillStyle = '#333';
            neuralCtx.font = '14px Arial';
            neuralCtx.fillText('×§×œ×˜', 20, neuralCanvas.height / 2);
            neuralCtx.fillText('×¤×œ×˜', neuralCanvas.width - 60, neuralCanvas.height / 2);
        }

        document.getElementById('layers').addEventListener('input', (e) => {
            document.getElementById('layersValue').textContent = e.target.value;
        });

        document.getElementById('neurons').addEventListener('input', (e) => {
            document.getElementById('neuronsValue').textContent = e.target.value;
        });

        document.getElementById('trainNeural').addEventListener('click', () => {
            if (isTrainingNeural) return;
            isTrainingNeural = true;
            const hiddenLayers = parseInt(document.getElementById('layers').value);
            const hiddenSize = parseInt(document.getElementById('neurons').value);
            document.getElementById('neuralStatus').textContent = '××××Ÿ...';
            
            setTimeout(() => {
                neuralNetwork = createNeuralNetwork(3, hiddenLayers, hiddenSize, 2);
                
                // ×¡×™××•×œ×¦×™×” ×©×œ ××™××•×Ÿ - ×¢×“×›×•×Ÿ ×¢×¨×›×™×
                let iteration = 0;
                const trainInterval = setInterval(() => {
                    neuralNetwork.layers.forEach(layer => {
                        layer.neurons.forEach(neuron => {
                            neuron.value = Math.sin(iteration * 0.1 + Math.random()) * 0.5 + 0.5;
                        });
                    });
                    drawNeuralNetwork();
                    iteration++;
                    
                    if (iteration > 30) {
                        clearInterval(trainInterval);
                        document.getElementById('neuralStatus').textContent = '××™××•×Ÿ ×”×•×©×œ×!';
                        isTrainingNeural = false;
                    }
                }, 50);
            }, 300);
        });

        document.getElementById('resetNeural').addEventListener('click', () => {
            neuralNetwork = null;
            drawNeuralNetwork();
            document.getElementById('neuralStatus').textContent = '××•×›×Ÿ ×œ××™××•×Ÿ';
        });

        // ××ª×—×•×œ
        drawNeuralNetwork();
    </script>
</body>
</html>
