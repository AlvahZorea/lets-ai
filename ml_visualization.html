<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª - ×¡×•×’×™ ×œ××™×“×” ××›×•× ×”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            direction: rtl;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        header h1 {
            color: #333;
            font-size: 42px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: #666;
            font-size: 18px;
            line-height: 1.6;
        }

        .tabs-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .tabs {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 15px 35px;
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            font-size: 17px;
            font-weight: 600;
            color: #555;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .tab:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            background: rgba(102, 126, 234, 0.2);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
        }

        .content-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 25px;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .panel-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .panel-header h2 {
            color: #333;
            font-size: 32px;
            margin-bottom: 12px;
        }

        .panel-header p {
            color: #666;
            font-size: 17px;
            line-height: 1.8;
        }

        .visualization-container {
            position: relative;
            width: 100%;
            height: 550px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            margin-bottom: 25px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group label {
            color: #555;
            font-weight: 600;
            font-size: 15px;
        }

        button {
            padding: 14px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        select {
            padding: 12px;
            border-radius: 10px;
            border: 2px solid #ddd;
            font-size: 15px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:hover {
            border-color: #667eea;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .info-box {
            background: linear-gradient(135deg, #f0f4ff 0%, #e8f0fe 100%);
            padding: 25px;
            border-radius: 15px;
            border-right: 5px solid #667eea;
            margin-bottom: 20px;
        }

        .info-box h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .info-box ul {
            color: #555;
            line-height: 2;
            padding-right: 25px;
            font-size: 16px;
        }

        .info-box li {
            margin-bottom: 8px;
        }

        .info-box strong {
            color: #667eea;
        }

        .hidden {
            display: none;
        }

        .status {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-radius: 12px;
            color: #2e7d32;
            font-weight: 600;
            font-size: 16px;
            margin-top: 20px;
            box-shadow: 0 2px 10px rgba(46, 125, 50, 0.2);
        }

        .status.training {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            color: #e65100;
        }

        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .example-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border-right: 4px solid #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s;
        }

        .example-card:hover {
            transform: translateY(-5px);
        }

        .example-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .example-card p {
            color: #666;
            font-size: 14px;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 32px;
            }

            .visualization-container {
                height: 400px;
            }

            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ¤– ×•×™×–×•××œ×™×–×¦×™×” ××™× ×˜×¨××§×˜×™×‘×™×ª - ×¡×•×’×™ ×œ××™×“×” ××›×•× ×”</h1>
            <p>×’×œ×” ××ª ×”×¢×•×œ× ×”××¨×ª×§ ×©×œ ×œ××™×“×” ××›×•× ×” ×“×¨×š ×•×™×–×•××œ×™×–×¦×™×•×ª ××™× ×˜×¨××§×˜×™×‘×™×•×ª ×•×—×•×•×™×™×ª×™×•×ª</p>
        </header>

        <div class="tabs-container">
            <div class="tabs">
                <button class="tab active" data-tab="supervised">ğŸ“š ×œ××™×“×” ××•× ×—×™×ª</button>
                <button class="tab" data-tab="unsupervised">ğŸ” ×œ××™×“×” ×œ× ××•× ×—×™×ª</button>
                <button class="tab" data-tab="reinforcement">ğŸ® ×œ××™×“×” ×‘×—×™×–×•×§</button>
                <button class="tab" data-tab="neural">ğŸ§  ×¨×©×ª×•×ª × ×•×™×¨×•× ×™×</button>
                <button class="tab" data-tab="deep">ğŸŒ ×œ××™×“×” ×¢××•×§×”</button>
            </div>
        </div>

        <!-- ×œ××™×“×” ××•× ×—×™×ª -->
        <div id="supervised" class="content-panel">
            <div class="panel-header">
                <h2>ğŸ“š ×œ××™×“×” ××•× ×—×™×ª (Supervised Learning)</h2>
                <p>×”××•×“×œ ×œ×•××“ ××ª×•×š ×“×•×’×××•×ª ××¡×•×× ×•×ª ×¢× ×ª×©×•×‘×•×ª × ×›×•× ×•×ª. ×›×•×œ×œ ×¡×™×•×•×’ (Classification) ×•×¨×’×¨×¡×™×” (Regression)</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>×¡×•×’ ××©×™××”:</label>
                    <select id="supervisedType">
                        <option value="classification">×¡×™×•×•×’ (Classification)</option>
                        <option value="regression">×¨×’×¨×¡×™×” (Regression)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>××¡×¤×¨ × ×§×•×“×•×ª × ×ª×•× ×™×: <span id="dataPointsValue">100</span></label>
                    <input type="range" id="dataPoints" min="30" max="300" step="10" value="100">
                </div>
                <div class="control-group">
                    <label>×¨××ª ×¨×¢×©: <span id="noiseValue">0.3</span></label>
                    <input type="range" id="noise" min="0.1" max="0.8" step="0.1" value="0.3">
                </div>
                <button id="trainSupervised">ğŸ“ ××™××•×Ÿ ×”××•×“×œ</button>
                <button id="resetSupervised">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="supervisedCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ××•× ×—×™×ª?</h3>
                <ul>
                    <li><strong>×¡×™×•×•×’ (Classification):</strong> ×—×™×–×•×™ ×§×˜×’×•×¨×™×” ×“×™×¡×§×¨×˜×™×ª (×œ××©×œ: ×—×ª×•×œ/×›×œ×‘, ×¡×¤××/×œ× ×¡×¤××, ××—×œ×”/×‘×¨×™×)</li>
                    <li><strong>×¨×’×¨×¡×™×” (Regression):</strong> ×—×™×–×•×™ ×¢×¨×š ××¡×¤×¨×™ ×¨×¦×™×£ (×œ××©×œ: ××—×™×¨ ×“×™×¨×”, ×˜××¤×¨×˜×•×¨×”, ××›×™×¨×•×ª)</li>
                    <li>×”××•×“×œ ×œ×•××“ ××ª×•×š ×“×•×’×××•×ª ×¢× ×ª×™×•×’×™× × ×›×•× ×™× (training data)</li>
                    <li>××˜×¨×ª×• ×œ×—×–×•×ª × ×›×•×Ÿ × ×ª×•× ×™× ×—×“×©×™× ×©×œ× ×¨××” ×‘×¢×‘×¨</li>
                </ul>
            </div>

            <div class="examples-grid">
                <div class="example-card">
                    <h4>ğŸ“§ ×–×™×”×•×™ ×¡×¤××</h4>
                    <p>×¡×™×•×•×’ ××™××™×™×œ×™× ×œ×¡×¤×× ××• ×œ× ×¡×¤×× ×¢×œ ×‘×¡×™×¡ ×ª×•×›×Ÿ ×”×”×•×“×¢×”</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ  ×—×™×–×•×™ ××—×™×¨×™ ×“×™×¨×•×ª</h4>
                    <p>×¨×’×¨×¡×™×” ×œ×—×™×–×•×™ ××—×™×¨ ×“×™×¨×” ×¢×œ ×‘×¡×™×¡ ×’×•×“×œ, ××™×§×•× ×•×ª×›×•× ×•×ª × ×•×¡×¤×•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ–¼ï¸ ×–×™×”×•×™ ×ª××•× ×•×ª</h4>
                    <p>×¡×™×•×•×’ ×ª××•× ×•×ª ×œ×§×˜×’×•×¨×™×•×ª: ×—×ª×•×œ, ×›×œ×‘, ××›×•× ×™×ª ×•×›×•'</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ’¬ × ×™×ª×•×— ×¡× ×˜×™×× ×˜</h4>
                    <p>×¡×™×•×•×’ ×‘×™×§×•×¨×•×ª ×œ××•×¦×¨×™× ×›×—×™×•×‘×™×•×ª, ×©×œ×™×œ×™×•×ª ××• × ×™×˜×¨×œ×™×•×ª</p>
                </div>
            </div>

            <div class="status" id="supervisedStatus">××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ '××™××•×Ÿ ×”××•×“×œ' ×›×“×™ ×œ×”×ª×—×™×œ</div>
        </div>

        <!-- ×œ××™×“×” ×œ× ××•× ×—×™×ª -->
        <div id="unsupervised" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ” ×œ××™×“×” ×œ× ××•× ×—×™×ª (Unsupervised Learning)</h2>
                <p>×”××•×“×œ ××•×¦× ×“×¤×•×¡×™× ×•×§×©×¨×™× ×‘× ×ª×•× ×™× ×œ×œ× ×ª×™×•×’×™×. ×›×•×œ×œ ×§×™×‘×•×¥ (Clustering) ×•×¦××¦×•× ×××“×™× (Dimensionality Reduction)</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>×¡×•×’ ××œ×’×•×¨×™×ª×:</label>
                    <select id="unsupervisedType">
                        <option value="kmeans">K-Means Clustering</option>
                        <option value="hierarchical">Hierarchical Clustering</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>××¡×¤×¨ ××©×›×•×œ×•×ª: <span id="clustersValue">4</span></label>
                    <input type="range" id="clusters" min="2" max="8" step="1" value="4">
                </div>
                <div class="control-group">
                    <label>××¡×¤×¨ × ×§×•×“×•×ª: <span id="unsupervisedPointsValue">150</span></label>
                    <input type="range" id="unsupervisedPoints" min="50" max="300" step="10" value="150">
                </div>
                <button id="trainUnsupervised">ğŸ“ ××¦× ××©×›×•×œ×•×ª</button>
                <button id="resetUnsupervised">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="unsupervisedCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ×œ× ××•× ×—×™×ª?</h3>
                <ul>
                    <li><strong>×§×™×‘×•×¥ (Clustering):</strong> ××¦×™××ª ×§×‘×•×¦×•×ª ×“×•××•×ª ×‘× ×ª×•× ×™× ×œ×œ× ×™×“×™×¢×” ××¨××© ××” ×”×Ÿ</li>
                    <li><strong>×¦××¦×•× ×××“×™×:</strong> ×”×¤×—×ª×ª ××¡×¤×¨ ×”×ª×›×•× ×•×ª ×ª×•×š ×©××™×¨×” ×¢×œ ×”××™×“×¢ ×”×—×©×•×‘ (PCA, t-SNE)</li>
                    <li>×”××•×“×œ ××•×¦× ×“×¤×•×¡×™× ×œ×œ× ×“×•×’×××•×ª ××¡×•×× ×•×ª - ×¨×§ ××”× ×ª×•× ×™× ×¢×¦××</li>
                    <li>×©×™××•×©×™ ×›××©×¨ ××™×Ÿ ×œ× ×• ×ª×™×•×’×™× ××• ×©×× ×—× ×• ××—×¤×©×™× ×“×¤×•×¡×™× ×—×‘×•×™×™×</li>
                </ul>
            </div>

            <div class="examples-grid">
                <div class="example-card">
                    <h4>ğŸ›’ ×”××œ×¦×•×ª ××•×¦×¨×™×</h4>
                    <p>×§×™×‘×•×¥ ×œ×§×•×—×•×ª ×œ×¤×™ ×”×ª× ×”×’×•×ª ×§× ×™×™×” ×›×“×™ ×œ×”×¦×™×¢ ×”××œ×¦×•×ª ××•×ª×××•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸš¨ ×–×™×”×•×™ ×× ×•××œ×™×•×ª</h4>
                    <p>×–×™×”×•×™ ×¤×¢×™×œ×•×ª ×—×¨×™×’×” ×‘×¨×©×ª ××• ×”×•× ××•×ª ×‘×›×¨×˜×™×¡×™ ××©×¨××™</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ“Š × ×™×ª×•×— ×©×•×§</h4>
                    <p>×—×œ×•×§×ª ×œ×§×•×—×•×ª ×œ×§×˜×’×•×¨×™×•×ª ×œ×¤×™ ×“×¤×•×¡×™ ×¦×¨×™×›×” ×•×”×ª× ×”×’×•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ§¬ ×‘×™×•××™× ×¤×•×¨××˜×™×§×”</h4>
                    <p>×§×™×‘×•×¥ ×’× ×™× ×œ×¤×™ ×“×¤×•×¡×™ ×‘×™×˜×•×™ ×“×•××™×</p>
                </div>
            </div>

            <div class="status" id="unsupervisedStatus">××•×›×Ÿ ×œ× ×™×ª×•×— - ×œ×—×¥ ×¢×œ '××¦× ××©×›×•×œ×•×ª' ×›×“×™ ×œ×”×ª×—×™×œ</div>
        </div>

        <!-- ×œ××™×“×” ×‘×—×™×–×•×§ -->
        <div id="reinforcement" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ® ×œ××™×“×” ×‘×—×™×–×•×§ (Reinforcement Learning)</h2>
                <p>×¡×•×›×Ÿ ×œ×•××“ ×“×¨×š ××™× ×˜×¨××§×¦×™×” ×¢× ×¡×‘×™×‘×”, ××§×‘×œ ×ª×’××•×œ×™× ×¢×œ ×¤×¢×•×œ×•×ª × ×›×•× ×•×ª ×•×× ×¡×” ×œ××§×¡× ××ª ×”×¨×•×•×— ×”×›×•×œ×œ</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>××”×™×¨×•×ª ×œ××™×“×” (Î±): <span id="learningRateValue">0.1</span></label>
                    <input type="range" id="learningRate" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <label>×’×•×¨× ×”× ×—×” (Î³): <span id="discountValue">0.9</span></label>
                    <input type="range" id="discount" min="0.5" max="0.99" step="0.01" value="0.9">
                </div>
                <div class="control-group">
                    <label>×¨××ª ××§×¡×¤×œ×•×¨×¦×™×” (Îµ): <span id="epsilonValue">0.2</span></label>
                    <input type="range" id="epsilon" min="0" max="1" step="0.05" value="0.2">
                </div>
                <button id="startRL">â–¶ ×”×ª×—×œ ××™××•×Ÿ</button>
                <button id="stopRL">â¸ ×¢×¦×•×¨</button>
                <button id="resetRL">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="reinforcementCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ×‘×—×™×–×•×§?</h3>
                <ul>
                    <li>×¡×•×›×Ÿ (Agent) ×œ×•××“ ×“×¨×š ××™× ×˜×¨××§×¦×™×” ×¢× ×¡×‘×™×‘×” (Environment)</li>
                    <li>××§×‘×œ ×ª×’××•×œ×™× (Rewards) ×—×™×•×‘×™×™× ××• ×©×œ×™×œ×™×™× ×¢×œ ×¤×¢×•×œ×•×ª</li>
                    <li>××˜×¨×ª×• ×œ××§×¡× ××ª ×¡×›×•× ×”×ª×’××•×œ×™× ×”×¢×ª×™×“×™×™× (Return)</li>
                    <li>×××–×Ÿ ×‘×™×Ÿ exploitation (×©×™××•×© ×‘×™×“×¢) ×•-exploration (×’×™×œ×•×™ ×—×“×©)</li>
                </ul>
            </div>

            <div class="examples-grid">
                <div class="example-card">
                    <h4>ğŸ¯ ××©×—×§×™×</h4>
                    <p>××œ×¤×-×’×•, ×©×—××˜, ×•××©×—×§×™ ×•×™×“××• - ×¡×•×›× ×™× ×©××©×—×§×™× ×‘×¨××” ×¢×œ-×× ×•×©×™×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ¤– ×¨×•×‘×•×˜×™×§×”</h4>
                    <p>×œ×™××•×“ ×”×œ×™×›×”, ×ª×¤×™×¡×” ×•×¤×¢×•×œ×•×ª ××•×¨×›×‘×•×ª ×‘×¡×‘×™×‘×” ×¤×™×–×™×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸš— × ×”×™×’×” ××•×˜×•× ×•××™×ª</h4>
                    <p>×§×‘×œ×ª ×”×—×œ×˜×•×ª ×‘×–××Ÿ ×××ª ×¢×œ ×‘×¡×™×¡ ×ª×’××•×œ×™× (×‘×˜×™×—×•×ª, ×™×¢×™×œ×•×ª)</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ“¦ × ×™×”×•×œ ××œ××™</h4>
                    <p>××•×¤×˜×™××™×–×¦×™×” ×©×œ ×”×–×× ×•×ª ×•××œ××™ ×œ××§×¡×•× ×¨×•×•×—×™×</p>
                </div>
            </div>

            <div class="status" id="reinforcementStatus">××•×›×Ÿ ×œ×”×ª×—×œ×” - ×œ×—×¥ ×¢×œ '×”×ª×—×œ ××™××•×Ÿ' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×•×›×Ÿ ×œ×•××“</div>
        </div>

        <!-- ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× -->
        <div id="neural" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸ§  ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× (Neural Networks)</h2>
                <p>××•×“×œ×™× ×”××‘×•×¡×¡×™× ×¢×œ ××‘× ×” ×”××•×—, ××•×¨×›×‘×™× ×× ×•×™×¨×•× ×™× ×”××—×•×‘×¨×™× ×‘×©×›×‘×•×ª ×•××¡×•×’×œ×™× ×œ×œ××•×“ ×“×¤×•×¡×™× ××•×¨×›×‘×™×</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>××¡×¤×¨ ×©×›×‘×•×ª × ×¡×ª×¨×•×ª: <span id="layersValue">3</span></label>
                    <input type="range" id="layers" min="1" max="6" step="1" value="3">
                </div>
                <div class="control-group">
                    <label>× ×•×™×¨×•× ×™× ×‘×©×›×‘×”: <span id="neuronsValue">6</span></label>
                    <input type="range" id="neurons" min="3" max="12" step="1" value="6">
                </div>
                <div class="control-group">
                    <label>××”×™×¨×•×ª ××™××•×Ÿ: <span id="trainSpeedValue">50</span>ms</label>
                    <input type="range" id="trainSpeed" min="20" max="200" step="10" value="50">
                </div>
                <button id="trainNeural">ğŸ“ ××™××•×Ÿ ×”×¨×©×ª</button>
                <button id="resetNeural">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×¨×©×ª×•×ª × ×•×™×¨×•× ×™×?</h3>
                <ul>
                    <li>××•×“×œ×™× ×”××—×§×™× ××ª ×¤×¢×•×œ×ª ×”××•×— ×”×× ×•×©×™ - × ×•×™×¨×•× ×™× ×”××—×•×‘×¨×™× ×–×” ×œ×–×”</li>
                    <li>××•×¨×›×‘×™× ××©×›×‘×•×ª: ×§×œ×˜ (Input), × ×¡×ª×¨×•×ª (Hidden), ×•×¤×œ×˜ (Output)</li>
                    <li>×œ×•××“×™× ×“×¤×•×¡×™× ××•×¨×›×‘×™× ×“×¨×š ×ª×”×œ×™×š ×©×œ backpropagation</li>
                    <li>×›×œ × ×•×™×¨×•×Ÿ ××—×©×‘ ×¤×•× ×§×¦×™×” ×©×œ ×”×§×œ×˜×™× ×©×œ×• ×•××¢×‘×™×¨ ××ª ×”×ª×•×¦××” ×”×œ××”</li>
                </ul>
            </div>

            <div class="examples-grid">
                <div class="example-card">
                    <h4>ğŸ–¼ï¸ ×–×™×”×•×™ ×ª××•× ×•×ª</h4>
                    <p>CNN (Convolutional Neural Networks) ×œ×–×™×”×•×™ ××•×‘×™×™×§×˜×™× ×‘×ª××•× ×•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ’¬ ×¢×™×‘×•×“ ×©×¤×”</h4>
                    <p>RNN ×•-LSTM ×œ×”×‘× ×ª ×˜×§×¡×˜ ×•×ª×¨×’×•× ××•×˜×•××˜×™</p>
                </div>
                <div class="example-card">
                    <h4>ğŸµ ×”××œ×¦×•×ª</h4>
                    <p>×¨×©×ª×•×ª × ×•×™×¨×•× ×™× ×œ×”××œ×¦×•×ª ××•×–×™×§×” ×•×¡×¨×˜×™× ××•×ª×××•×ª ××™×©×™×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ¥ ××‘×—×•×Ÿ ×¨×¤×•××™</h4>
                    <p>×–×™×”×•×™ ××—×œ×•×ª ×‘×ª××•× ×•×ª ×¨× ×˜×’×Ÿ ×•×¡×¨×™×§×•×ª ×¨×¤×•××™×•×ª</p>
                </div>
            </div>

            <div class="status" id="neuralStatus">××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ '××™××•×Ÿ ×”×¨×©×ª' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¨×©×ª ××ª××× ×ª</div>
        </div>

        <!-- ×œ××™×“×” ×¢××•×§×” -->
        <div id="deep" class="content-panel hidden">
            <div class="panel-header">
                <h2>ğŸŒ ×œ××™×“×” ×¢××•×§×” (Deep Learning)</h2>
                <p>×¨×©×ª×•×ª × ×•×™×¨×•× ×™× ×¢××•×§×•×ª ×¢× ×©×›×‘×•×ª ×¨×‘×•×ª, ××¡×•×’×œ×•×ª ×œ×œ××•×“ ×™×™×¦×•×’×™× ××•×¨×›×‘×™× ×××•×“ ×©×œ ×”× ×ª×•× ×™×</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>×¡×•×’ ×¨×©×ª:</label>
                    <select id="deepType">
                        <option value="cnn">CNN - Convolutional</option>
                        <option value="rnn">RNN - Recurrent</option>
                        <option value="transformer">Transformer</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>×¢×•××§ ×”×¨×©×ª: <span id="depthValue">5</span> ×©×›×‘×•×ª</label>
                    <input type="range" id="depth" min="3" max="10" step="1" value="5">
                </div>
                <div class="control-group">
                    <label>×’×•×“×œ batch: <span id="batchValue">32</span></label>
                    <input type="range" id="batch" min="8" max="128" step="8" value="32">
                </div>
                <button id="trainDeep">ğŸ“ ××™××•×Ÿ ×¨×©×ª ×¢××•×§×”</button>
                <button id="resetDeep">ğŸ”„ ××™×¤×•×¡</button>
            </div>

            <div class="visualization-container">
                <canvas id="deepCanvas"></canvas>
            </div>

            <div class="info-box">
                <h3>ğŸ’¡ ××” ×–×” ×œ××™×“×” ×¢××•×§×”?</h3>
                <ul>
                    <li><strong>CNN:</strong> Convolutional Neural Networks - ××¦×•×™× ×•×ª ×‘×¢×™×‘×•×“ ×ª××•× ×•×ª ×•×•×™×“××•</li>
                    <li><strong>RNN:</strong> Recurrent Neural Networks - ××ª××™××•×ª ×œ× ×ª×•× ×™× ×¨×¦×™×¤×™× ×›××• ×˜×§×¡×˜ ×•×–××Ÿ</li>
                    <li><strong>Transformer:</strong> ××¨×›×™×˜×§×˜×•×¨×” ×—×“×©×” ×”××‘×•×¡×¡×ª ×¢×œ attention - ×©×™××•×©×™×ª ×××•×“ ×‘-NLP</li>
                    <li>×¨×©×ª×•×ª ×¢××•×§×•×ª ×œ×•××“×•×ª ×™×™×¦×•×’×™× ×”×™×¨×¨×›×™×™× - ××©×›×‘×•×ª × ××•×›×•×ª (×§×•×•×™×, ×¦×•×¨×•×ª) ×œ×©×›×‘×•×ª ×’×‘×•×”×•×ª (××•×‘×™×™×§×˜×™×, ××•×©×’×™×)</li>
                </ul>
            </div>

            <div class="examples-grid">
                <div class="example-card">
                    <h4>ğŸ¤– ChatGPT & GPT</h4>
                    <p>Transformer models ×œ×™×¦×™×¨×ª ×˜×§×¡×˜, ×©×™×—×” ×•×ª×¨×’×•×</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ‘ï¸ ×–×™×”×•×™ ×¤× ×™×</h4>
                    <p>CNN ×œ×–×™×”×•×™ ×¤× ×™×, ×¨×’×©×•×ª ×•×¤×¢×•×œ×•×ª ×‘×ª××•× ×•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸš— × ×”×™×’×” ××•×˜×•× ×•××™×ª</h4>
                    <p>×¨×©×ª×•×ª ×¢××•×§×•×ª ×œ×–×™×”×•×™ ××•×‘×™×™×§×˜×™×, ×ª××¨×•× ×™× ×•×§×‘×œ×ª ×”×—×œ×˜×•×ª</p>
                </div>
                <div class="example-card">
                    <h4>ğŸ¨ ×™×¦×™×¨×ª ××× ×•×ª</h4>
                    <p>GANs ×•-Diffusion models ×œ×™×¦×™×¨×ª ×ª××•× ×•×ª ×•××× ×•×ª AI</p>
                </div>
            </div>

            <div class="status" id="deepStatus">××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ '××™××•×Ÿ ×¨×©×ª ×¢××•×§×”' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¨×©×ª ×”×¢××•×§×” ××ª××× ×ª</div>
        </div>
    </div>

    <script>
        // ========== × ×™×”×•×œ ×˜××‘×™× ==========
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('.content-panel').forEach(p => p.classList.add('hidden'));
                document.getElementById(targetTab).classList.remove('hidden');
                
                // ×¢×“×›×•×Ÿ ×’×•×“×œ ×§× ×‘×¡×™×
                setTimeout(() => {
                    [supervisedCanvas, unsupervisedCanvas, reinforcementCanvas, neuralCanvas, deepCanvas].forEach(canvas => {
                        if (canvas) resizeCanvas(canvas);
                    });
                }, 100);
            });
        });

        // ========== ×¤×•× ×§×¦×™×” ×›×œ×œ×™×ª ×œ×©×™× ×•×™ ×’×•×“×œ ×§× ×‘×¡ ==========
        function resizeCanvas(canvas) {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        // ========== ×œ××™×“×” ××•× ×—×™×ª ==========
        const supervisedCanvas = document.getElementById('supervisedCanvas');
        const supervisedCtx = supervisedCanvas.getContext('2d');
        let supervisedData = [];
        let supervisedModel = null;
        let isTrainingSupervised = false;

        resizeCanvas(supervisedCanvas);
        window.addEventListener('resize', () => resizeCanvas(supervisedCanvas));

        function generateSupervisedData(type, count, noise) {
            const data = [];
            const width = supervisedCanvas.width;
            const height = supervisedCanvas.height;
            
            for (let i = 0; i < count; i++) {
                const x = Math.random() * width;
                let y;
                
                if (type === 'classification') {
                    const cluster = Math.random() < 0.5 ? 0 : 1;
                    const centerX = cluster === 0 ? width * 0.3 : width * 0.7;
                    const centerY = height * 0.5;
                    const offsetX = (Math.random() - 0.5) * width * 0.25 * noise;
                    const offsetY = (Math.random() - 0.5) * height * 0.3 * noise;
                    y = centerY + offsetY + Math.sin(x / width * Math.PI * 3) * height * 0.15;
                    data.push({ x, y, label: cluster });
                } else {
                    y = height * 0.2 + (x / width) * height * 0.5 + (Math.random() - 0.5) * height * 0.3 * noise;
                    data.push({ x, y });
                }
            }
            
            return data;
        }

        function drawSupervised(type) {
            supervisedCtx.clearRect(0, 0, supervisedCanvas.width, supervisedCanvas.height);
            
            if (type === 'classification') {
                supervisedData.forEach(point => {
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                    supervisedCtx.fillStyle = point.label === 0 ? '#e74c3c' : '#3498db';
                    supervisedCtx.fill();
                    supervisedCtx.strokeStyle = 'white';
                    supervisedCtx.lineWidth = 2;
                    supervisedCtx.stroke();
                });
                
                if (supervisedModel) {
                    supervisedCtx.strokeStyle = '#2ecc71';
                    supervisedCtx.lineWidth = 4;
                    supervisedCtx.setLineDash([]);
                    supervisedCtx.beginPath();
                    const midX = supervisedCanvas.width / 2;
                    supervisedCtx.moveTo(midX, 0);
                    supervisedCtx.lineTo(midX, supervisedCanvas.height);
                    supervisedCtx.stroke();
                    
                    // ××–×•×¨ ×”×—×™×–×•×™
                    supervisedCtx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                    supervisedCtx.fillRect(0, 0, midX, supervisedCanvas.height);
                    supervisedCtx.fillStyle = 'rgba(52, 152, 219, 0.1)';
                    supervisedCtx.fillRect(midX, 0, midX, supervisedCanvas.height);
                }
            } else {
                supervisedData.forEach(point => {
                    supervisedCtx.beginPath();
                    supervisedCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    supervisedCtx.fillStyle = '#9b59b6';
                    supervisedCtx.fill();
                    supervisedCtx.strokeStyle = 'white';
                    supervisedCtx.lineWidth = 1.5;
                    supervisedCtx.stroke();
                });
                
                if (supervisedModel) {
                    supervisedCtx.strokeStyle = '#e67e22';
                    supervisedCtx.lineWidth = 4;
                    supervisedCtx.setLineDash([]);
                    supervisedCtx.beginPath();
                    for (let x = 0; x < supervisedCanvas.width; x += 3) {
                        const y = Math.max(0, Math.min(supervisedCanvas.height, supervisedModel.slope * x + supervisedModel.intercept));
                        if (x === 0) supervisedCtx.moveTo(x, y);
                        else supervisedCtx.lineTo(x, y);
                    }
                    supervisedCtx.stroke();
                }
            }
        }

        document.getElementById('supervisedType').addEventListener('change', (e) => {
            const count = parseInt(document.getElementById('dataPoints').value);
            const noise = parseFloat(document.getElementById('noise').value);
            supervisedData = generateSupervisedData(e.target.value, count, noise);
            supervisedModel = null;
            drawSupervised(e.target.value);
        });

        document.getElementById('dataPoints').addEventListener('input', (e) => {
            document.getElementById('dataPointsValue').textContent = e.target.value;
            const type = document.getElementById('supervisedType').value;
            const noise = parseFloat(document.getElementById('noise').value);
            supervisedData = generateSupervisedData(type, parseInt(e.target.value), noise);
            supervisedModel = null;
            drawSupervised(type);
        });

        document.getElementById('noise').addEventListener('input', (e) => {
            document.getElementById('noiseValue').textContent = parseFloat(e.target.value).toFixed(1);
            const type = document.getElementById('supervisedType').value;
            const count = parseInt(document.getElementById('dataPoints').value);
            supervisedData = generateSupervisedData(type, count, parseFloat(e.target.value));
            supervisedModel = null;
            drawSupervised(type);
        });

        document.getElementById('trainSupervised').addEventListener('click', () => {
            if (isTrainingSupervised) return;
            isTrainingSupervised = true;
            const type = document.getElementById('supervisedType').value;
            const statusEl = document.getElementById('supervisedStatus');
            statusEl.textContent = '××××Ÿ...';
            statusEl.className = 'status training';
            
            setTimeout(() => {
                if (type === 'classification') {
                    supervisedModel = { trained: true };
                } else {
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    supervisedData.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        sumXY += p.x * p.y;
                        sumX2 += p.x * p.x;
                    });
                    const n = supervisedData.length;
                    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const intercept = (sumY - slope * sumX) / n;
                    supervisedModel = { slope, intercept };
                }
                drawSupervised(type);
                statusEl.textContent = 'âœ… ××™××•×Ÿ ×”×•×©×œ× ×‘×”×¦×œ×—×”! ×”××•×“×œ ××•×›×Ÿ ×œ×—×™×–×•×™';
                statusEl.className = 'status';
                isTrainingSupervised = false;
            }, 1500);
        });

        document.getElementById('resetSupervised').addEventListener('click', () => {
            const type = document.getElementById('supervisedType').value;
            const count = parseInt(document.getElementById('dataPoints').value);
            const noise = parseFloat(document.getElementById('noise').value);
            supervisedData = generateSupervisedData(type, count, noise);
            supervisedModel = null;
            drawSupervised(type);
            document.getElementById('supervisedStatus').textContent = '××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ \'××™××•×Ÿ ×”××•×“×œ\' ×›×“×™ ×œ×”×ª×—×™×œ';
            document.getElementById('supervisedStatus').className = 'status';
        });

        // ××ª×—×•×œ
        const supervisedType = document.getElementById('supervisedType').value;
        supervisedData = generateSupervisedData(supervisedType, 100, 0.3);
        drawSupervised(supervisedType);

        // ========== ×œ××™×“×” ×œ× ××•× ×—×™×ª ==========
        const unsupervisedCanvas = document.getElementById('unsupervisedCanvas');
        const unsupervisedCtx = unsupervisedCanvas.getContext('2d');
        let unsupervisedData = [];
        let clusters = [];
        let isTrainingUnsupervised = false;

        resizeCanvas(unsupervisedCanvas);
        window.addEventListener('resize', () => resizeCanvas(unsupervisedCanvas));

        function generateUnsupervisedData(count) {
            const data = [];
            const width = unsupervisedCanvas.width;
            const height = unsupervisedCanvas.height;
            
            const centers = [
                { x: width * 0.25, y: height * 0.25 },
                { x: width * 0.75, y: height * 0.25 },
                { x: width * 0.25, y: height * 0.75 },
                { x: width * 0.75, y: height * 0.75 },
                { x: width * 0.5, y: height * 0.5 }
            ];
            
            for (let i = 0; i < count; i++) {
                const center = centers[Math.floor(Math.random() * centers.length)];
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * Math.min(width, height) * 0.12;
                data.push({
                    x: center.x + Math.cos(angle) * radius,
                    y: center.y + Math.sin(angle) * radius
                });
            }
            
            return data;
        }

        function kMeans(data, k) {
            const width = unsupervisedCanvas.width;
            const height = unsupervisedCanvas.height;
            
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * width,
                    y: Math.random() * height
                });
            }
            
            for (let iter = 0; iter < 15; iter++) {
                const assignments = data.map(point => {
                    let minDist = Infinity;
                    let cluster = 0;
                    centroids.forEach((centroid, idx) => {
                        const dist = Math.sqrt(
                            Math.pow(point.x - centroid.x, 2) + 
                            Math.pow(point.y - centroid.y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            cluster = idx;
                        }
                    });
                    return cluster;
                });
                
                centroids = centroids.map((_, idx) => {
                    const clusterPoints = data.filter((_, i) => assignments[i] === idx);
                    if (clusterPoints.length === 0) return centroids[idx];
                    const sumX = clusterPoints.reduce((s, p) => s + p.x, 0);
                    const sumY = clusterPoints.reduce((s, p) => s + p.y, 0);
                    return {
                        x: sumX / clusterPoints.length,
                        y: sumY / clusterPoints.length
                    };
                });
            }
            
            return { centroids, assignments };
        }

        function drawUnsupervised() {
            unsupervisedCtx.clearRect(0, 0, unsupervisedCanvas.width, unsupervisedCanvas.height);
            
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
            
            if (clusters.length > 0 && clusters.assignments) {
                unsupervisedData.forEach((point, idx) => {
                    const cluster = clusters.assignments[idx];
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = colors[cluster % colors.length];
                    unsupervisedCtx.fill();
                    unsupervisedCtx.strokeStyle = 'white';
                    unsupervisedCtx.lineWidth = 2;
                    unsupervisedCtx.stroke();
                });
                
                clusters.centroids.forEach((centroid, idx) => {
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(centroid.x, centroid.y, 15, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = colors[idx % colors.length];
                    unsupervisedCtx.fill();
                    unsupervisedCtx.strokeStyle = 'white';
                    unsupervisedCtx.lineWidth = 4;
                    unsupervisedCtx.stroke();
                    
                    // ××¢×’×œ ×¡×‘×™×‘ ×”××¨×›×–
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(centroid.x, centroid.y, 30, 0, Math.PI * 2);
                    unsupervisedCtx.strokeStyle = colors[idx % colors.length];
                    unsupervisedCtx.lineWidth = 2;
                    unsupervisedCtx.setLineDash([5, 5]);
                    unsupervisedCtx.stroke();
                    unsupervisedCtx.setLineDash([]);
                });
            } else {
                unsupervisedData.forEach(point => {
                    unsupervisedCtx.beginPath();
                    unsupervisedCtx.arc(point.x, point.y, 7, 0, Math.PI * 2);
                    unsupervisedCtx.fillStyle = '#95a5a6';
                    unsupervisedCtx.fill();
                    unsupervisedCtx.strokeStyle = 'white';
                    unsupervisedCtx.lineWidth = 2;
                    unsupervisedCtx.stroke();
                });
            }
        }

        document.getElementById('clusters').addEventListener('input', (e) => {
            document.getElementById('clustersValue').textContent = e.target.value;
        });

        document.getElementById('unsupervisedPoints').addEventListener('input', (e) => {
            document.getElementById('unsupervisedPointsValue').textContent = e.target.value;
        });

        document.getElementById('trainUnsupervised').addEventListener('click', () => {
            if (isTrainingUnsupervised) return;
            isTrainingUnsupervised = true;
            const k = parseInt(document.getElementById('clusters').value);
            const statusEl = document.getElementById('unsupervisedStatus');
            statusEl.textContent = '××—×©×‘ ××©×›×•×œ×•×ª...';
            statusEl.className = 'status training';
            
            setTimeout(() => {
                clusters = kMeans(unsupervisedData, k);
                drawUnsupervised();
                statusEl.textContent = `âœ… × ××¦××• ${k} ××©×›×•×œ×•×ª ×‘×”×¦×œ×—×”!`;
                statusEl.className = 'status';
                isTrainingUnsupervised = false;
            }, 1200);
        });

        document.getElementById('resetUnsupervised').addEventListener('click', () => {
            const count = parseInt(document.getElementById('unsupervisedPoints').value);
            unsupervisedData = generateUnsupervisedData(count);
            clusters = [];
            drawUnsupervised();
            document.getElementById('unsupervisedStatus').textContent = '××•×›×Ÿ ×œ× ×™×ª×•×— - ×œ×—×¥ ×¢×œ \'××¦× ××©×›×•×œ×•×ª\' ×›×“×™ ×œ×”×ª×—×™×œ';
            document.getElementById('unsupervisedStatus').className = 'status';
        });

        unsupervisedData = generateUnsupervisedData(150);
        drawUnsupervised();

        // ========== ×œ××™×“×” ×‘×—×™×–×•×§ ==========
        const reinforcementCanvas = document.getElementById('reinforcementCanvas');
        const reinforcementCtx = reinforcementCanvas.getContext('2d');
        let agent = { x: 0, y: 0 };
        let target = { x: 0, y: 0 };
        let obstacles = [];
        let rlAnimation = null;
        let episode = 0;
        let score = 0;
        let totalReward = 0;

        resizeCanvas(reinforcementCanvas);
        window.addEventListener('resize', () => resizeCanvas(reinforcementCanvas));

        function initRL() {
            agent.x = reinforcementCanvas.width * 0.1;
            agent.y = reinforcementCanvas.height * 0.5;
            target.x = reinforcementCanvas.width * 0.9;
            target.y = reinforcementCanvas.height * 0.5;
            
            obstacles = [];
            for (let i = 0; i < 3; i++) {
                obstacles.push({
                    x: Math.random() * reinforcementCanvas.width * 0.7 + reinforcementCanvas.width * 0.15,
                    y: Math.random() * reinforcementCanvas.height * 0.7 + reinforcementCanvas.height * 0.15,
                    radius: 25 + Math.random() * 20
                });
            }
        }

        function drawRL() {
            reinforcementCtx.clearRect(0, 0, reinforcementCanvas.width, reinforcementCanvas.height);
            
            reinforcementCtx.fillStyle = '#ecf0f1';
            reinforcementCtx.fillRect(0, 0, reinforcementCanvas.width, reinforcementCanvas.height);
            
            // ××›×©×•×œ×™×
            obstacles.forEach(obs => {
                reinforcementCtx.beginPath();
                reinforcementCtx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                reinforcementCtx.fillStyle = '#e74c3c';
                reinforcementCtx.fill();
                reinforcementCtx.strokeStyle = '#c0392b';
                reinforcementCtx.lineWidth = 3;
                reinforcementCtx.stroke();
            });
            
            // ××˜×¨×”
            reinforcementCtx.beginPath();
            reinforcementCtx.arc(target.x, target.y, 25, 0, Math.PI * 2);
            reinforcementCtx.fillStyle = '#2ecc71';
            reinforcementCtx.fill();
            reinforcementCtx.strokeStyle = '#27ae60';
            reinforcementCtx.lineWidth = 4;
            reinforcementCtx.stroke();
            
            // ×¡×•×›×Ÿ
            reinforcementCtx.beginPath();
            reinforcementCtx.arc(agent.x, agent.y, 18, 0, Math.PI * 2);
            reinforcementCtx.fillStyle = '#3498db';
            reinforcementCtx.fill();
            reinforcementCtx.strokeStyle = '#2980b9';
            reinforcementCtx.lineWidth = 3;
            reinforcementCtx.stroke();
            
            // ××™×“×¢
            reinforcementCtx.fillStyle = '#333';
            reinforcementCtx.font = 'bold 18px Arial';
            reinforcementCtx.fillText(`××¤×™×–×•×“×”: ${episode}`, 20, 35);
            reinforcementCtx.fillText(`× ×™×§×•×“: ${score}`, 20, 65);
            reinforcementCtx.fillText(`×ª×’××•×œ ×›×•×œ×œ: ${totalReward.toFixed(1)}`, 20, 95);
        }

        document.getElementById('learningRate').addEventListener('input', (e) => {
            document.getElementById('learningRateValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('discount').addEventListener('input', (e) => {
            document.getElementById('discountValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('epsilon').addEventListener('input', (e) => {
            document.getElementById('epsilonValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('startRL').addEventListener('click', () => {
            if (rlAnimation) return;
            
            initRL();
            episode = 0;
            score = 0;
            totalReward = 0;
            
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const discount = parseFloat(document.getElementById('discount').value);
            const epsilon = parseFloat(document.getElementById('epsilon').value);
            
            rlAnimation = setInterval(() => {
                const dx = target.x - agent.x;
                const dy = target.y - agent.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 30) {
                    const moveX = (dx / dist) * 4 + (Math.random() - 0.5) * 8 * epsilon;
                    const moveY = (dy / dist) * 4 + (Math.random() - 0.5) * 8 * epsilon;
                    
                    agent.x += moveX;
                    agent.y += moveY;
                    
                    agent.x = Math.max(18, Math.min(reinforcementCanvas.width - 18, agent.x));
                    agent.y = Math.max(18, Math.min(reinforcementCanvas.height - 18, agent.y));
                    
                    // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ×‘××›×©×•×œ×™×
                    let collision = false;
                    obstacles.forEach(obs => {
                        const distToObs = Math.sqrt(
                            Math.pow(agent.x - obs.x, 2) + 
                            Math.pow(agent.y - obs.y, 2)
                        );
                        if (distToObs < obs.radius + 18) {
                            collision = true;
                        }
                    });
                    
                    if (collision) {
                        totalReward -= 5;
                    } else {
                        totalReward += 0.1;
                    }
                } else {
                    score += 10;
                    totalReward += 20;
                    episode++;
                    initRL();
                }
                
                drawRL();
            }, 60);
            
            document.getElementById('reinforcementStatus').textContent = '××ª×××Ÿ... ×”×¡×•×›×Ÿ ×œ×•××“ ×œ××¦×•× ××ª ×”××˜×¨×”';
            document.getElementById('reinforcementStatus').className = 'status training';
        });

        document.getElementById('stopRL').addEventListener('click', () => {
            if (rlAnimation) {
                clearInterval(rlAnimation);
                rlAnimation = null;
                document.getElementById('reinforcementStatus').textContent = `×¢×¦×•×¨ - ×”×•×©×œ××• ${episode} ××¤×™×–×•×“×•×ª ×¢× × ×™×§×•×“ ${score}`;
                document.getElementById('reinforcementStatus').className = 'status';
            }
        });

        document.getElementById('resetRL').addEventListener('click', () => {
            if (rlAnimation) {
                clearInterval(rlAnimation);
                rlAnimation = null;
            }
            initRL();
            episode = 0;
            score = 0;
            totalReward = 0;
            drawRL();
            document.getElementById('reinforcementStatus').textContent = '××•×›×Ÿ ×œ×”×ª×—×œ×” - ×œ×—×¥ ×¢×œ \'×”×ª×—×œ ××™××•×Ÿ\' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×•×›×Ÿ ×œ×•××“';
            document.getElementById('reinforcementStatus').className = 'status';
        });

        initRL();
        drawRL();

        // ========== ×¨×©×ª×•×ª × ×•×™×¨×•× ×™× ==========
        const neuralCanvas = document.getElementById('neuralCanvas');
        const neuralCtx = neuralCanvas.getContext('2d');
        let neuralNetwork = null;
        let isTrainingNeural = false;
        let trainingInterval = null;

        resizeCanvas(neuralCanvas);
        window.addEventListener('resize', () => resizeCanvas(neuralCanvas));

        function createNeuralNetwork(inputSize, hiddenLayers, hiddenSize, outputSize) {
            const network = {
                layers: []
            };
            
            network.layers.push({
                neurons: Array(inputSize).fill(0).map(() => ({ value: Math.random() }))
            });
            
            for (let i = 0; i < hiddenLayers; i++) {
                network.layers.push({
                    neurons: Array(hiddenSize).fill(0).map(() => ({ value: Math.random() }))
                });
            }
            
            network.layers.push({
                neurons: Array(outputSize).fill(0).map(() => ({ value: Math.random() }))
            });
            
            return network;
        }

        function drawNeuralNetwork() {
            neuralCtx.clearRect(0, 0, neuralCanvas.width, neuralCanvas.height);
            
            if (!neuralNetwork) return;
            
            const layers = neuralNetwork.layers;
            const layerWidth = neuralCanvas.width / (layers.length + 1);
            const neuronRadius = 22;
            
            layers.forEach((layer, layerIdx) => {
                const x = layerWidth * (layerIdx + 1);
                const neuronSpacing = neuralCanvas.height / (layer.neurons.length + 1);
                
                layer.neurons.forEach((neuron, neuronIdx) => {
                    const y = neuronSpacing * (neuronIdx + 1);
                    
                    if (layerIdx < layers.length - 1) {
                        const nextLayer = layers[layerIdx + 1];
                        const nextNeuronSpacing = neuralCanvas.height / (nextLayer.neurons.length + 1);
                        const nextX = layerWidth * (layerIdx + 2);
                        
                        nextLayer.neurons.forEach((_, nextNeuronIdx) => {
                            const nextY = nextNeuronSpacing * (nextNeuronIdx + 1);
                            
                            neuralCtx.beginPath();
                            neuralCtx.moveTo(x, y);
                            neuralCtx.lineTo(nextX, nextY);
                            const intensity = Math.abs(neuron.value) * 0.4;
                            neuralCtx.strokeStyle = `rgba(102, 126, 234, ${intensity})`;
                            neuralCtx.lineWidth = 1.5;
                            neuralCtx.stroke();
                        });
                    }
                    
                    neuralCtx.beginPath();
                    neuralCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    const intensity = Math.min(1, Math.abs(neuron.value));
                    neuralCtx.fillStyle = `rgba(102, 126, 234, ${intensity})`;
                    neuralCtx.fill();
                    neuralCtx.strokeStyle = '#667eea';
                    neuralCtx.lineWidth = 3;
                    neuralCtx.stroke();
                });
            });
            
            neuralCtx.fillStyle = '#333';
            neuralCtx.font = 'bold 16px Arial';
            neuralCtx.fillText('×§×œ×˜', 25, neuralCanvas.height / 2);
            neuralCtx.fillText('×¤×œ×˜', neuralCanvas.width - 70, neuralCanvas.height / 2);
        }

        document.getElementById('layers').addEventListener('input', (e) => {
            document.getElementById('layersValue').textContent = e.target.value;
        });

        document.getElementById('neurons').addEventListener('input', (e) => {
            document.getElementById('neuronsValue').textContent = e.target.value;
        });

        document.getElementById('trainSpeed').addEventListener('input', (e) => {
            document.getElementById('trainSpeedValue').textContent = e.target.value;
        });

        document.getElementById('trainNeural').addEventListener('click', () => {
            if (isTrainingNeural) return;
            isTrainingNeural = true;
            const hiddenLayers = parseInt(document.getElementById('layers').value);
            const hiddenSize = parseInt(document.getElementById('neurons').value);
            const speed = parseInt(document.getElementById('trainSpeed').value);
            const statusEl = document.getElementById('neuralStatus');
            statusEl.textContent = '××××Ÿ ×¨×©×ª...';
            statusEl.className = 'status training';
            
            neuralNetwork = createNeuralNetwork(4, hiddenLayers, hiddenSize, 3);
            drawNeuralNetwork();
            
            let iteration = 0;
            trainingInterval = setInterval(() => {
                neuralNetwork.layers.forEach(layer => {
                    layer.neurons.forEach(neuron => {
                        neuron.value = Math.sin(iteration * 0.15 + Math.random() * 2) * 0.5 + 0.5;
                    });
                });
                drawNeuralNetwork();
                iteration++;
                
                if (iteration > 40) {
                    clearInterval(trainingInterval);
                    statusEl.textContent = 'âœ… ××™××•×Ÿ ×”×•×©×œ×! ×”×¨×©×ª ××•×›× ×” ×œ×©×™××•×©';
                    statusEl.className = 'status';
                    isTrainingNeural = false;
                }
            }, speed);
        });

        document.getElementById('resetNeural').addEventListener('click', () => {
            if (trainingInterval) {
                clearInterval(trainingInterval);
                trainingInterval = null;
            }
            neuralNetwork = null;
            isTrainingNeural = false;
            drawNeuralNetwork();
            document.getElementById('neuralStatus').textContent = '××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ \'××™××•×Ÿ ×”×¨×©×ª\' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¨×©×ª ××ª××× ×ª';
            document.getElementById('neuralStatus').className = 'status';
        });

        drawNeuralNetwork();

        // ========== ×œ××™×“×” ×¢××•×§×” ==========
        const deepCanvas = document.getElementById('deepCanvas');
        const deepCtx = deepCanvas.getContext('2d');
        let deepNetwork = null;
        let isTrainingDeep = false;
        let deepTrainingInterval = null;

        resizeCanvas(deepCanvas);
        window.addEventListener('resize', () => resizeCanvas(deepCanvas));

        function createDeepNetwork(type, depth) {
            const network = {
                type: type,
                layers: []
            };
            
            const sizes = type === 'cnn' ? [32, 64, 128, 256, 128, 64] : 
                         type === 'rnn' ? [50, 100, 150, 100, 50] :
                         [128, 256, 512, 256, 128];
            
            for (let i = 0; i < depth; i++) {
                const size = sizes[i % sizes.length];
                network.layers.push({
                    neurons: Array(size).fill(0).map(() => ({ value: Math.random() }))
                });
            }
            
            return network;
        }

        function drawDeepNetwork() {
            deepCtx.clearRect(0, 0, deepCanvas.width, deepCanvas.height);
            
            if (!deepNetwork) return;
            
            const layers = deepNetwork.layers;
            const layerWidth = deepCanvas.width / (layers.length + 1);
            const neuronRadius = 15;
            
            layers.forEach((layer, layerIdx) => {
                const x = layerWidth * (layerIdx + 1);
                const maxNeurons = Math.max(...layers.map(l => l.neurons.length));
                const neuronSpacing = deepCanvas.height / (maxNeurons + 1);
                
                layer.neurons.forEach((neuron, neuronIdx) => {
                    const y = neuronSpacing * (neuronIdx + 1);
                    
                    if (layerIdx < layers.length - 1) {
                        const nextLayer = layers[layerIdx + 1];
                        const nextNeuronSpacing = deepCanvas.height / (maxNeurons + 1);
                        const nextX = layerWidth * (layerIdx + 2);
                        
                        nextLayer.neurons.forEach((_, nextNeuronIdx) => {
                            const nextY = nextNeuronSpacing * (nextNeuronIdx + 1);
                            
                            deepCtx.beginPath();
                            deepCtx.moveTo(x, y);
                            deepCtx.lineTo(nextX, nextY);
                            const intensity = Math.abs(neuron.value) * 0.2;
                            deepCtx.strokeStyle = `rgba(156, 39, 176, ${intensity})`;
                            deepCtx.lineWidth = 0.8;
                            deepCtx.stroke();
                        });
                    }
                    
                    deepCtx.beginPath();
                    deepCtx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    const intensity = Math.min(1, Math.abs(neuron.value));
                    deepCtx.fillStyle = `rgba(156, 39, 176, ${intensity})`;
                    deepCtx.fill();
                    deepCtx.strokeStyle = '#9c27b0';
                    deepCtx.lineWidth = 2;
                    deepCtx.stroke();
                });
            });
            
            deepCtx.fillStyle = '#333';
            deepCtx.font = 'bold 16px Arial';
            deepCtx.fillText(deepNetwork.type.toUpperCase(), deepCanvas.width / 2 - 40, 30);
        }

        document.getElementById('depth').addEventListener('input', (e) => {
            document.getElementById('depthValue').textContent = e.target.value;
        });

        document.getElementById('batch').addEventListener('input', (e) => {
            document.getElementById('batchValue').textContent = e.target.value;
        });

        document.getElementById('trainDeep').addEventListener('click', () => {
            if (isTrainingDeep) return;
            isTrainingDeep = true;
            const type = document.getElementById('deepType').value;
            const depth = parseInt(document.getElementById('depth').value);
            const statusEl = document.getElementById('deepStatus');
            statusEl.textContent = '××××Ÿ ×¨×©×ª ×¢××•×§×”... ×–×” ×¢×©×•×™ ×œ×§×—×ª ×–××Ÿ';
            statusEl.className = 'status training';
            
            deepNetwork = createDeepNetwork(type, depth);
            drawDeepNetwork();
            
            let iteration = 0;
            deepTrainingInterval = setInterval(() => {
                deepNetwork.layers.forEach(layer => {
                    layer.neurons.forEach(neuron => {
                        neuron.value = Math.sin(iteration * 0.1 + Math.random() * 3) * 0.5 + 0.5;
                    });
                });
                drawDeepNetwork();
                iteration++;
                
                if (iteration > 60) {
                    clearInterval(deepTrainingInterval);
                    statusEl.textContent = 'âœ… ××™××•×Ÿ ×¨×©×ª ×¢××•×§×” ×”×•×©×œ×!';
                    statusEl.className = 'status';
                    isTrainingDeep = false;
                }
            }, 80);
        });

        document.getElementById('resetDeep').addEventListener('click', () => {
            if (deepTrainingInterval) {
                clearInterval(deepTrainingInterval);
                deepTrainingInterval = null;
            }
            deepNetwork = null;
            isTrainingDeep = false;
            drawDeepNetwork();
            document.getElementById('deepStatus').textContent = '××•×›×Ÿ ×œ××™××•×Ÿ - ×œ×—×¥ ×¢×œ \'××™××•×Ÿ ×¨×©×ª ×¢××•×§×”\' ×›×“×™ ×œ×¨××•×ª ××ª ×”×¨×©×ª ×”×¢××•×§×” ××ª××× ×ª';
            document.getElementById('deepStatus').className = 'status';
        });

        document.getElementById('deepType').addEventListener('change', () => {
            if (deepNetwork) {
                const depth = parseInt(document.getElementById('depth').value);
                deepNetwork = createDeepNetwork(document.getElementById('deepType').value, depth);
                drawDeepNetwork();
            }
        });

        drawDeepNetwork();
    </script>
</body>
</html>
